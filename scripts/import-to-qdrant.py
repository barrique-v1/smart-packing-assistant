#!/usr/bin/env python3
"""
Import embeddings to Qdrant vector database.

This script:
1. Reads embeddings from JSON file (generated by generate-embeddings.py)
2. Creates Qdrant collection if it doesn't exist
3. Uploads vectors in batches
4. Verifies import success

Usage:
    python3 scripts/import-to-qdrant.py [--qdrant-url http://localhost:6333]
"""

import json
import sys
import argparse
import requests
from typing import List, Dict, Any
from tqdm import tqdm
import time

# Configuration
EMBEDDINGS_FILE = "data/packing-embeddings.json"
COLLECTION_NAME = "packing_knowledge"
VECTOR_SIZE = 1536
DISTANCE = "Cosine"  # Cosine distance for semantic similarity
BATCH_SIZE = 100  # Upload in batches for better performance
RETRY_ATTEMPTS = 3
RETRY_DELAY = 2  # seconds

def load_embeddings(file_path: str) -> Dict[str, Any]:
    """Load embeddings from JSON file."""
    print(f"üìñ Loading embeddings from {file_path}...")

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        points = data.get('points', [])
        metadata = data.get('metadata', {})

        print(f"‚úÖ Loaded {len(points)} points from file")
        print(f"   Model: {metadata.get('embedding_model')}")
        print(f"   Dimensions: {metadata.get('dimensions')}")
        print(f"   Generated: {metadata.get('generated_at')}")

        return data

    except FileNotFoundError:
        print(f"‚ùå Error: File not found: {file_path}")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"‚ùå Error parsing JSON: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Error loading file: {e}")
        sys.exit(1)

def check_qdrant_health(qdrant_url: str) -> bool:
    """Check if Qdrant is accessible."""
    print(f"\nüîç Checking Qdrant connection at {qdrant_url}...")

    try:
        response = requests.get(f"{qdrant_url}/healthz", timeout=5)
        response.raise_for_status()
        print("‚úÖ Qdrant is healthy and accessible")
        return True
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Cannot connect to Qdrant: {e}")
        print(f"   Make sure Qdrant is running at {qdrant_url}")
        return False

def collection_exists(qdrant_url: str, collection_name: str) -> bool:
    """Check if collection already exists."""
    try:
        response = requests.get(f"{qdrant_url}/collections/{collection_name}")
        return response.status_code == 200
    except requests.exceptions.RequestException:
        return False

def create_collection(qdrant_url: str, collection_name: str, vector_size: int, distance: str):
    """Create Qdrant collection with specified configuration."""
    print(f"\nüîß Creating collection '{collection_name}'...")

    config = {
        "vectors": {
            "size": vector_size,
            "distance": distance
        },
        "optimizers_config": {
            "indexing_threshold": 10000  # Start indexing after 10k points
        }
    }

    try:
        response = requests.put(
            f"{qdrant_url}/collections/{collection_name}",
            json=config,
            timeout=10
        )
        response.raise_for_status()
        print(f"‚úÖ Collection '{collection_name}' created successfully")
        print(f"   Vector size: {vector_size}")
        print(f"   Distance metric: {distance}")
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Failed to create collection: {e}")
        if hasattr(e.response, 'text'):
            print(f"   Response: {e.response.text}")
        sys.exit(1)

def delete_collection(qdrant_url: str, collection_name: str):
    """Delete existing collection."""
    print(f"üóëÔ∏è  Deleting existing collection '{collection_name}'...")

    try:
        response = requests.delete(
            f"{qdrant_url}/collections/{collection_name}",
            timeout=10
        )
        response.raise_for_status()
        print(f"‚úÖ Collection deleted")
        time.sleep(1)  # Wait for deletion to complete
    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è  Warning: Failed to delete collection: {e}")

def upload_points(qdrant_url: str, collection_name: str, points: List[Dict[str, Any]]):
    """Upload points to Qdrant in batches."""
    print(f"\nüì§ Uploading {len(points)} points to Qdrant...")
    print(f"   Batch size: {BATCH_SIZE}")

    total_uploaded = 0

    # Process in batches
    for i in tqdm(range(0, len(points), BATCH_SIZE), desc="Uploading batches"):
        batch = points[i:i + BATCH_SIZE]

        # Retry logic for uploads
        for attempt in range(RETRY_ATTEMPTS):
            try:
                response = requests.put(
                    f"{qdrant_url}/collections/{collection_name}/points",
                    json={"points": batch},
                    timeout=30
                )
                response.raise_for_status()

                total_uploaded += len(batch)
                break  # Success - break retry loop

            except requests.exceptions.RequestException as e:
                if attempt < RETRY_ATTEMPTS - 1:
                    print(f"\n‚ö†Ô∏è  Upload error (attempt {attempt + 1}/{RETRY_ATTEMPTS}): {e}")
                    print(f"   Retrying in {RETRY_DELAY} seconds...")
                    time.sleep(RETRY_DELAY)
                else:
                    print(f"\n‚ùå Failed to upload batch after {RETRY_ATTEMPTS} attempts: {e}")
                    if hasattr(e.response, 'text'):
                        print(f"   Response: {e.response.text}")
                    sys.exit(1)

        # Small delay between batches
        if i + BATCH_SIZE < len(points):
            time.sleep(0.1)

    print(f"\n‚úÖ Successfully uploaded {total_uploaded} points")

def verify_import(qdrant_url: str, collection_name: str, expected_count: int):
    """Verify that all points were imported correctly."""
    print(f"\n‚úîÔ∏è  Verifying import...")

    try:
        response = requests.get(f"{qdrant_url}/collections/{collection_name}")
        response.raise_for_status()

        data = response.json()
        result = data.get('result', {})
        points_count = result.get('points_count', 0)
        vectors_count = result.get('vectors_count', 0)

        print(f"   Points in collection: {points_count}")
        print(f"   Vectors in collection: {vectors_count}")

        if points_count == expected_count:
            print(f"‚úÖ Import verified successfully - all {expected_count} points imported")
            return True
        else:
            print(f"‚ö†Ô∏è  Warning: Expected {expected_count} points, but found {points_count}")
            return False

    except requests.exceptions.RequestException as e:
        print(f"‚ùå Verification failed: {e}")
        return False

def print_sample_search(qdrant_url: str, collection_name: str, points: List[Dict[str, Any]]):
    """Perform a sample search to demonstrate functionality."""
    print(f"\nüîç Testing search with sample query...")

    if not points:
        return

    # Use first point's vector for test search
    test_vector = points[0]['vector']
    test_item = points[0]['payload']['item']

    search_request = {
        "vector": test_vector,
        "limit": 5,
        "with_payload": True,
        "with_vector": False
    }

    try:
        response = requests.post(
            f"{qdrant_url}/collections/{collection_name}/points/search",
            json=search_request,
            timeout=10
        )
        response.raise_for_status()

        results = response.json().get('result', [])

        print(f"   Query item: {test_item}")
        print(f"   Top 5 results:")

        for idx, result in enumerate(results, 1):
            item = result['payload']['item']
            score = result['score']
            category = result['payload']['category']
            print(f"      {idx}. {item} ({category}) - score: {score:.4f}")

    except requests.exceptions.RequestException as e:
        print(f"‚ö†Ô∏è  Sample search failed: {e}")

def main():
    """Main execution function."""
    parser = argparse.ArgumentParser(description='Import embeddings to Qdrant')
    parser.add_argument(
        '--qdrant-url',
        default='http://localhost:6333',
        help='Qdrant URL (default: http://localhost:6333)'
    )
    parser.add_argument(
        '--recreate',
        action='store_true',
        help='Delete existing collection and recreate'
    )

    args = parser.parse_args()

    print("=" * 70)
    print("  Smart Packing Assistant - Qdrant Import")
    print("=" * 70)

    # Load embeddings
    data = load_embeddings(EMBEDDINGS_FILE)
    points = data.get('points', [])

    if not points:
        print("‚ùå No points to import")
        sys.exit(1)

    # Check Qdrant health
    if not check_qdrant_health(args.qdrant_url):
        sys.exit(1)

    # Handle existing collection
    if collection_exists(args.qdrant_url, COLLECTION_NAME):
        if args.recreate:
            delete_collection(args.qdrant_url, COLLECTION_NAME)
            create_collection(args.qdrant_url, COLLECTION_NAME, VECTOR_SIZE, DISTANCE)
        else:
            print(f"\n‚ö†Ô∏è  Collection '{COLLECTION_NAME}' already exists")
            print("   Use --recreate to delete and recreate, or continue to add points")
            response = input("   Continue? [y/N]: ").strip().lower()
            if response != 'y':
                print("Aborted")
                sys.exit(0)
    else:
        create_collection(args.qdrant_url, COLLECTION_NAME, VECTOR_SIZE, DISTANCE)

    # Upload points
    upload_points(args.qdrant_url, COLLECTION_NAME, points)

    # Verify import
    verify_import(args.qdrant_url, COLLECTION_NAME, len(points))

    # Sample search
    print_sample_search(args.qdrant_url, COLLECTION_NAME, points)

    print("\n" + "=" * 70)
    print("‚úÖ Import complete!")
    print("=" * 70)
    print(f"\nCollection '{COLLECTION_NAME}' is ready for use.")
    print(f"Total vectors: {len(points)}")
    print(f"\nYou can now test the AI Worker with real vector search:")
    print(f"  curl -X POST http://localhost:8081/api/ai/generate \\")
    print(f"    -H 'Content-Type: application/json' \\")
    print(f"    -d '{{\"destination\":\"Paris\",\"durationDays\":5,\"season\":\"SUMMER\",\"travelType\":\"VACATION\"}}'")
    print()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
